<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex,nofollow">
    <title>State Machines</title>
</head>

<body>
    <h1>State Machines</h1>
    <article aria-labelledby="intro">
        <h2 id="intro">Einführung</h2>
        <h3>Statecharts</h3>
        <p><img src="https://statecharts.github.io/on-off.svg" alt="A simple statechart"></p>
        <p>Statecharts visualiseren <a href="https://statecharts.github.io/what-is-a-state-machine.html">State Machines</a> (Zustandsautomaten) und ergänzen diese. Sie helfen im Besonderen, <a href="https://statecharts.github.io/state-machine-state-explosion.html">Zustandsexplosionen</a> zu verhindern.</p>
        <h4>Statecharts und State Machines bieten einige Vorteile</h4>
        <ul>
            <li>Es ist leichter <a href="https://statecharts.github.io/benefit-easy-to-understand.html">ein Chart zu verstehen</a> als Code.</li>
            <li>Das <a href="https://statecharts.github.io/benefit-decoupled-behaviour-component.html">Verhalten ist entkoppelt</a> von der Komponente an sich.
                <ul>
                    <li>macht es <a href="https://statecharts.github.io/benefit-make-changes-to-the-behaviour.html">einfacher, Änderungen am Verhalten vorzunehmen</a></li>
                    <li>kleine Funktionen <a href="https://statecharts.github.io/benefit-reason-about-code.html">vereinfachen die Codeanalyse</a></li>
                    <li>Verhalten kann <a href="https://statecharts.github.io/benefit-testable-behaviour.html">unabhängig getestet werden</a>, ohne Blick auf Komponente</li>
                </ul>
            </li>
            <li>Der Erstellungsprozess eines Statecharts führt dazu, <a href="https://statecharts.github.io/benefit-all-states-explored.html">alle möglichen Zustände offenzulegen</a>.</li>
            <li>Studien haben gezeigt, dass Statechart-basierter Code <a href="https://statecharts.github.io/benefit-low-bug-count.html">weniger Bugs enthält</a> als sonst üblich.</li>
            <li>Statecharts bewirken ein intensiveres Nachdenken über <a href="https://statecharts.github.io/benefit-handle-anomalies.html">Randfälle</a>, die sonst schnell übersehen werden.</li>
            <li>Wenn die Komplexität zunimmt, <a href="https://statecharts.github.io/benefit-scales-with-complexity.html">skalieren sie gut</a>.</li>
            <li>Es ist eine gute Kommunikationsmöglichkeit: Nicht-Entwickler <a href="https://statecharts.github.io/benefit-non-developers-understanding.html">verstehen es</a>, QA <a href="benefit-qa-exploration-tool.html">verwendet es zur Analyse</a>.</li>
        </ul>
        <p>State Machines <a href="https://statecharts.github.io/benefit-explicit.html">verwendest du bereits jetzt schon</a>, allerdings eher im Code verborgen. Sobald du ein <code>if (result == null)</code> im Code hast, hat dein Code zwei Zustände (<a href="https://statecharts.github.io/use-case-statecharts-in-user-interfaces.html">Use-Case für Statecharts in UI</a>).</p>
        <h4>Wesentliche Nachteile</h4>
        <ul>
            <li>Mit Statecharts müssen Entwickler <a href="https://statecharts.github.io/drawback-learn-new-technique.html">etwas Neues lernen</a>.</li>
            <li>Der Einsatz von Statecharts ist <a href="https://statecharts.github.io/drawback-foreign-paradigm.html">ein weniger üblicher Weg in der Entwicklung</a>, weshalb Teams diese Umstellung ablehnen.</li>
            <li>Bei kleinen Statecharts entsteht durch das separat definierte Verhalten ein Overhead, der <a href="https://statecharts.github.io/drawback-lines-of-code.html">mehr Codezeilen als üblich</a> zur Folge hat.</li>
        </ul>
        <h3>XState</h3>
        <p>Ausführbare Statecharts eignen sich in der Entwicklung besonders. Häufig empfohlen wird <a href="https://xstate.js.org/">XState</a> als Frontend-Framework.</p>
        <ul>
            <li>ist eine JavaScript-Bibliothek</li>
            <li>zur Umsetzung endlicher (finite state machines) und unendlicher Zustandsautomaten geeignet</li>
            <li>bietet einen <a href="https://xstate.js.org/viz/">eigenen Visualizer</a></li>
            <li>es gibt ein Package zur Integration in Vue-Anwendungen</li>
            <li>bewegt sich sehr nah am <a href="https://www.sciencedirect.com/science/article/pii/0167642387900359/pdf">ursprünglichen Konzept der Statecharts</a></li>
            <li>beinhaltet Konzepte, wie Hierarchien (verschachtelte State Machines), parallele State Machines and Historie</li>
        </ul>
    </article>
    <nav aria-labelledby="examples">
        <h2 id="examples">Beispiele</h2>
        <ol>
            <li><a href="./payment-classic.html">Payment ohne State Machine</a></li>
            <li><a href="./payment-machine.html">Payment State Machine</a></li>
            <li><a href="./payment-vue-machine.html">Payment State Machine mit Vue</a></li>
            <!-- <li><a href="./timer-machine.html">Timer Machine</a></li> -->
        </ol>
    </nav>
    <nav aria-labelledby="more">
        <h2 id="more">Mehr erfahren</h2>
        <ul>
            <li><a href="https://statecharts.github.io/">Welcome to the world of Statecharts</a></li>
            <li><a href="https://xstate.js.org/">XState</a></li>
        </ul>
    </nav>
</body>

</html>